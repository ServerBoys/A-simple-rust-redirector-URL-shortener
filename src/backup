
extern crate hyper;
extern crate mysql_async as mysql;

use hyper::{Body, Response, Server};
use mysql::{prelude::Queryable, Pool};
use mysql::chrono::Utc;
use std::convert::Infallible;

#[derive(Debug, serde::Serialize, serde::Deserialize)]
struct UrlMapping {
    slug: String,
    url: String,
}

async fn handle_request(req: hyper::Request<Body>, pool: mysql::Pool) -> Result<Response<Body>, Infallible> {
    // Extract slug from URL path
    let slug = match req.uri().path_and_query() {
        Some(s) => s.path().split('/').nth(1).unwrap_or("").to_string(),
        None => return Ok(Response::builder().status(400).body(Body::empty()).unwrap()),
    };

    // Query database for slug
    let mut conn = pool.get_conn().await.unwrap();
    let sql = "SELECT * FROM urls WHERE slug = ?";
    let row = conn.query_first(sql, (&slug)).await.unwrap();

    // Check if slug exists
    let url_mapping: Option<UrlMapping> = match row {
        Some(row) => Some(UrlMapping {
            slug: row.get("slug").unwrap(),
            url: row.get("url").unwrap(),
        }),
        None => None,
    };

    // Respond based on result
    let response = match url_mapping {
        Some(mapping) => {
            let body = format!("Redirecting to {}", mapping.url);
            Response::builder()
                .status(301)
                .header("Location", mapping.url.clone())
                .body(Body::from(body))
                .unwrap()
        }
        None => {
            Response::builder()
                .status(404)
                .body(Body::from("Slug not found"))
                .unwrap()
        }
    };

    Ok(response)
}

#[tokio::main]
async fn main() {
    let addr = "127.0.0.1:8080".parse().unwrap();
    let pool = Pool::new("mysql://username:password@localhost/dbname");

    println!("Listening on http://{}", addr);
    let make_svc = hyper::service::make_service_fn(|_conn| {
        let pool = pool.clone();
        async { Ok::<_, Infallible>(hyper::service::service_fn(move |req| {
            handle_request(req, pool.clone())
        })) }
    });

    let server = Server::bind(&addr).serve(make_svc);

    if let Err(e) = server.await {
        eprintln!("server error: {}", e);
    }
}

extern crate hyper;
extern crate mysql_async as mysql;

use hyper::{Body, Response, Server};
use mysql::{prelude::Queryable, Pool};
use mysql::chrono::Utc;
use std::convert::Infallible;

#[derive(Debug, serde::Serialize, serde::Deserialize)]
struct UrlMapping {
    slug: String,
    url: String,
}

async fn handle_request(req: hyper::Request<Body>, pool: mysql::Pool) -> Result<Response<Body>, Infallible> {
    // Extract slug from URL path
    let slug = match req.uri().path_and_query() {
        Some(s) => s.path().split('/').nth(1).unwrap_or("").to_string(),
        None => return Ok(Response::builder().status(400).body(Body::empty()).unwrap()),
    };

    // Query database for slug
    let mut conn = pool.get_conn().await.unwrap();
    let sql = "SELECT * FROM urls WHERE slug = ?";
    let row = conn.query_first(sql, (&slug)).await.unwrap();

    // Check if slug exists
    let url_mapping: Option<UrlMapping> = match row {
        Some(row) => Some(UrlMapping {
            slug: row.get("slug").unwrap(),
            url: row.get("url").unwrap(),
        }),
        None => None,
    };

    // Respond based on result
    let response = match url_mapping {
        Some(mapping) => {
            let body = format!("Redirecting to {}", mapping.url);
            Response::builder()
                .status(301)
                .header("Location", mapping.url.clone())
                .body(Body::from(body))
                .unwrap()
        }
        None => {
            Response::builder()
                .status(404)
                .body(Body::from("Slug not found"))
                .unwrap()
        }
    };

    Ok(response)
}

#[tokio::main]
async fn main() {
    let addr = "127.0.0.1:8080".parse().unwrap();
    let pool = Pool::new("mysql://username:password@localhost/dbname");

    println!("Listening on http://{}", addr);
    let make_svc = hyper::service::make_service_fn(|_conn| {
        let pool = pool.clone();
        async { Ok::<_, Infallible>(hyper::service::service_fn(move |req| {
            handle_request(req, pool.clone())
        })) }
    });

    let server = Server::bind(&addr).serve(make_svc);

    if let Err(e) = server.await {
        eprintln!("server error: {}", e);
    }
}
